---
description: '英文版白皮書: https://bitcoin.org/bitcoin.pdf​'
---

# 【簡体】比特币白皮書

## 零、 摘要

完全以端对端（peer-to-peer）技术实现的电子现金系统允许线上支付可以不必透过金融机构而直接从某一方传送。虽然数位签章（digital signature）解决了部分的问题，但若需要信任的第三方才能避免双重支付（double-spending）的话，这个系统就没有价值了。

我们提出了一个端对端的网路来解决双重支付的问题，此网路透过以下方式**对每一笔交易做时间戳记**（timestamp），也就是将每一笔交易杂凑（hash）到一个「**基于杂凑的工作量证明**」（hash-based-proof-work）组成的一条不断延伸的链（chain）上，除非重新完成所有工作量证明，这些纪录将不能被更改。最长的链不仅扮演了一连串目击事件的证明，也证明了它来自于一个 CPU 运算能力很大的池。

只要多数的 CPU 运算能力都由不会联合攻击网路的节点（node）所控制的话，诚实的节点就会产生一条最长且超越其他攻击者的链。这个网路本身需要的基础建设很少，讯息会依据最大努力原则（best effort basis）广播出去，而**节点可自由选择离开或重新加入网路**、且**接受最长的工作量证明所组成的链**作为节点离开时所发生的交易事件之证明。

## ㄧ、介紹

网际网路的商业应用几乎都仰赖金融机构作为处理电子支付之信任的第三方。虽然系统在大多数情况下都能运作良好，但这类系统仍有以信任为基础的模式这项固有的缺点。由于金融机构无法避免出面调解争议，因此完全不可逆的交易并不真的可行。因为调解成本而提高的交易成本，将会限制最小的实际交易规糢、限制了日常小额支付、失去为不可逆之服务进行的不可逆支付的能力进而造成更广泛的成本。可逆性的服务让信任的需求增加，商人必须更加警惕自己的客户，因此会向他们索取完全不必要的个人资讯。一定比例的诈骗可以被接受并认为是无法避免的。以上这些成本及支付的不确定性在使用实体货币时皆可避免，但透过一个缺乏第三方信任的沟通渠道进行支付的机制并不存在。我们所需要的是一个以加密证明取代信任的电子支付系统，且允许任何达成共识的双方能够直接交易，而不需信任的第三方参与。计算不可逆（Computationally impractical to reverse）的交易可以避免卖方受骗，而常规性托管机制（routine escrow mechanisms）则可以轻易地让买方被保护。在这篇论文中，我们透过一个P2P的分散式时间戳记伺服器去产生按时间排序的交易之计算证明，进而解决了双重支付的问题。只要诚实的节点能够共同合作去控制比攻击者族群更多的 CPU 运算能力，这个系统就会是安全的。

## 二、交易（Transactions）

我们定义一颗电子货币为一串数位签章。每位拥有者为前一个交易及下一位拥有者的公开金钥（public key）签署一个杂凑的数位签章，并将之加入一颗货币的尾端，透过上述的方式将货币发送给下一位拥有者。收款者可以透过检查签章（signature）来验证该链的拥有者。

![&#x4EA4;&#x6613;&#xFF08;Transactions&#xFF09;](https://cdn-images-1.medium.com/max/800/1*jS8e6OsOo_qS7wHRqdfvaQ.png)

这个过程的问题在于收款者无法验证拥有者是否对这颗货币进行双重支付。一般解法为导入一个信任的中央权威机构或是造币厂来验证每一笔交易，以防止双重支付。在每一笔交易之后，货币必须送回造币厂以发行新货币，且只有直接从造币厂发行的货币才会被信任为没有双重支付。然而，这个解法的问题在于整个金钱系统的命运皆仰赖在像银行一样会经手每笔交易的造币厂公司。我们需要一个方法让收款者知道前一位拥有者并没有签署更早发生的交易，由于我们计较的是在此之前发生的交易，因此不用在意在此之后是否有双重支付。证实交易存在的唯一方法是去意识到所有交易的发生，而在以造币厂为基础的糢式中，造币厂必须意识到所有交易并决定交易完成的先后顺序。为了在没有信任的第三方的之情况下达到目的，交易必须被公告，且我们需要一个让所有参与者在他们接收的顺序上达成共识的系统。收款者需要确保在交易期间绝大多数的节点都认同该交易是首次出现。

## 三、時間戳記伺服器（Timestamp Server）

我们提出的解法先由时间戳记伺服器说起。时间戳记伺服器会将由很多交易组成的区块（block）所对应之杂凑加上时间戳记，并如同在报纸或 Usenet中发送的方法将杂凑进行广播。时间戳记证明了资料在进入杂凑时必然存在。每个时间戳记应将前一个时间戳记加入其杂凑中，之后的每一个时间戳记都和前一个时间戳记进行增强\(reinforce\)，而形成了一条链。

![&#x6642;&#x9593;&#x6233;&#x8A18;&#x4F3A;&#x670D;&#x5668;&#xFF08;Timestamp Server&#xFF09;](https://cdn-images-1.medium.com/max/800/1*9ZVjRXzbPOAtEUT1fk_Ftg.png)

## 四、 工作量證明（Proof-of-Work）

为了在端对端的基础上去实现一个分散式时间戳记伺服器，我们需使用一个类似 Adam Back 提出的 Hashcash 技术的工作量证明系统，而非像报纸或 Usenet 的发送方法。工作量证明包括扫描一个数值，以 SHA-256 安全杂凑演算法（Secure Hash Algorithm）为例，杂凑值以一个或多个 0 开始。平均而言，随着 0 的数目上升、所需之工作量将呈指数增加，且可藉由执行一次杂凑运算即完成验证。在我们的时间戳记网路中，我们藉由增加区块中 nonce 的数量直到提供区块所对应之杂凑足够数量的 0 之 nounce 值被发现来完成工作量证明。一旦 CPU 的贡献扩大到足以满足工作量证明，除非重新完成一定的工作量否则该区块无法被更改。当后来的区块在此之后被链结上，若想更改区块，则需要完成之后所有区块的工作量。

![&#x5DE5;&#x4F5C;&#x91CF;&#x8B49;&#x660E;&#xFF08;Proof of Work&#xFF09;](https://cdn-images-1.medium.com/max/800/1*rh6Y2EScZjST7Ojqs_dxWw.png)

工作量证明也解决了多数决代表的问题。如果多数是建立在一个 IP 位址对应一票的基础上，则会被任何可以拥有许多 IP 者所推翻。工作量证明本质上是一个 CPU 对应一票。多数决代表为最长的链，因为最长的链包含了最大的工作量。如果大多数的 CPU 运算能力是由诚实的节点所控制，则此诚实的链将会成长为最快速且超越任何一条竞争者的链。若要修改先前的区块，攻击者必须重新完成该区块及在它之后的所有区块的工作量证明，并赶上且超越诚实节点之工作量。我们稍后会说明较慢的攻击者赶上的机率会随着之后的区块增加而呈指数消减。\[注1\]为了解决因硬体速度的增加及节点参与网路的程度起伏之问题，工作量证明的难度是由每小时平均产生之区块数量而决定。如果区块答案越快被算出、则难度也会随之增加。

## 五、網路（Network）

以下是网路运作的步骤：新的交易会向所有节点广播每个节点会蒐集加入区块的新交易每个节点负责为其区块找到一条够困难的工作量证明当节点找到工作量证明后，会向所有节点广播节点只有在节点中的所有交易为有效且尚未存在过时，才会接受区块为有效的节点会使用已接纳之区块的杂凑作为之前的杂凑来创造链上的新区块，来表示接受该区块节点始终会将最长的链视为正确的且持续延长。若有两个节点同时广播两个不同版本的新区块，部分节点可能会先接收到其中一种。在这种情况下，节点会先处理先接收到的区块，但也会保存另一条分支链以免它变成最长的链。当下一个工作量证明被发现且其中一条链被证实为较长的一条时，这样的僵局会被打破，此时，原本在另一条分支链上工作的节点会转而处理较长的这条链。新交易的广播并不一定要触及所有节点，只要这些交易广播到足够多的节点，不久后这些交易就会被整合进一个区块。区块的广播同样可以容许漏掉讯息，若某个节点没有接收到特定区块，当这个节点接收到下一个区块时，就会认知到它遗漏了一个区块并可提出自己下载该区块的请求。

## 六、 獎勵（Incentive）

按照惯例，区块中的第一个交易较特别，因为它产生了一颗由该区块建立者所拥有的新货币。这激励了节点\(矿工\)去支持整个网路，且在没有中央权威机构发行货币的情况下，提供了初期货币流通的方法。新货币数量的稳定增加和矿工为了增加黄金流通而耗费资源去挖矿类似。而在我们的案例中，耗费的资源是 CPU 运算时间和消耗的电力。奖励也可以来自于交易手续费。交易的输入值减掉输出值即为交易的手续费，提供交易所在之区块的奖励。一旦既定数量的货币进入流通，奖励机制就可以完全依靠交易手续费且能免于通货膨胀。奖励机制也有助于鼓励节点保持诚实。若有贪婪的攻击者能够装备比所有诚实节点还要多的 CPU 运算能力，那麽他将面临以下选择：进行双重支付的攻击或是用于诚实工作来产生新货币。他将会发现遵循规则将是更有利可图的，因为比起破坏系统及自身财产的合法性，遵守规则能够使他拥有更多的电子货币。

## 七、 回收磁碟空間（Reclaiming Disk Space）

当一个货币的最新交易被整合进足够数量的区块中，则可丢弃在此交易之前的资料以节省磁碟空间。为了不破坏区块的 hash，交易资讯会被 hash 至一颗 Merkle Tree 中，且只有根包含在区块 hash 中。旧的区块接着可藉由去除树的分支来压缩，内部的 hash 也不需要被保存。

![&#x56DE;&#x6536;&#x78C1;&#x789F;&#x5340;&#xFF08;Reclaiming Disk Space&#xFF09;](https://cdn-images-1.medium.com/max/800/1*oLgRVR3joPISJdXHF9OR4w.png)

不含交易资讯的区块标头（header）约为 80 bytes，假设每十分钟产生一个区块，则一年需要 80 bytes  _6_  24 \* 365 = 4.2 MB。由于 2008 年贩售的电脑系统搭载 2GB 的 RAM，且 Moore’s law 预测每年可成长 1.2 GB，因此，即便区块标头必须被保存在记忆体中也不会是问题。

## 八、簡化的支付驗證（Simplified Payment Verification）

不运行整个网路的节点\(≒170GB\)来验证支付是可行的，使用者只需要保存最长的工作量证明链的区块标头档案即可，此备份可藉由不断询问网路节点直到它被证可为最长链来取得，且透过 Merkle Tree 的分支链结上被加上时间戳记且被整合进区块的交易。虽然使用者本来就无法自行验证交易的有效性，但藉由跟全网的其他帐本进行连结后、使用者就可以看到网路上的节点是否接受过这笔交易纪录，且藉由之后加上的区块愈多、你更可以进一步证明了整个网路承认这笔交易的存在性与真实性。

![&#x7C21;&#x5316;&#x7684;&#x652F;&#x4ED8;&#x9A57;&#x8B49;&#xFF08;Simplified Payment Verification&#xFF09;](https://cdn-images-1.medium.com/max/800/1*0m4XX-g3DHC9leN32cbzDg.png)

因此，只要诚实的节点控制了网路，验证机制就会是可靠的。但若攻击者拥有过多运算能力的话，验证机制就会变得较脆弱。因为网路节点可以自己验证交易，一旦攻击者持续掌控了整个网路，这样简易的验证方法将会被攻击者所产生的交易欺骗。为了避免这样的情况发生，当网路节点侦测到无效的区块时就会发出警报，并提示使用者的软体去下载整个区块以及被警告有问题的交易来对资讯的前后不一致做判定。对于频繁接收支付的商业机构而言，可能会为了更独立的安全性及更快速的验证而希望能够运行自己的节点。

## 九、 幣值的結合與分割（Combining and Splitting Value）

虽然可以个别处理货币，但要为每次转帐时每一颗\(分\)货币都建立一个单独的交易是很麻烦的。为了让币值得以结合及分割，交易将会有许多输入与输出。通常会有前一个交易共同组成的多重输入，且输出最多只会有两个：一个为支付的费用，另一个为必要时的找零。

![&#x5E63;&#x503C;&#x7684;&#x7D50;&#x5408;&#x8207;&#x5206;&#x5272;&#xFF08;Combining and Splitting Value&#xFF09;](https://cdn-images-1.medium.com/max/800/1*4hLF4AlS1uK0CVDxDRBMjg.png)

值得注意的是，一个交易依赖很多笔交易；而那些交易又依赖更多笔交易，但这不会是一个问题，因为这个运作并不需要去展开并验证一个交易的历史资料。

## 十、隱私（Privacy）

传统银行的模式是藉由限制交易的参与者及信任的第三方取得资讯的权限来达到一定程度的隐私，但若公开发佈所有交易就牴触了上述的方法，但仍可藉由保持公开金钥的匿名性来维持隐私。大众可以看到某人传了一笔金额给另一人，但却无法得知这笔交易对应到谁。这和股票交易所释出的交易资讯是同样等级的，也就是可以知道交易发生的时间与交易量，但无法得知交易的两方是谁。

![&#x96B1;&#x79C1;&#xFF08;Privacy&#xFF09;](https://cdn-images-1.medium.com/max/800/1*vdbe2UvElK7Szi44_YX1rg.png)

作为额外的预防措施，一对新的金钥应该让每笔交易避免被链结到同一个拥有者。有些链结仍不免为多重输入的交易，这也代表这些输入被同一人所拥有，这样的风险在于一旦拥有者的金钥被揭露，这些链结可能也会同时揭露了来自这个拥有者的其他交易。

## 十一、計算（Calculations）\[註2\]

即便一个攻击者比诚实链更快速产生一条替代的链，也无法让系统变成可任意变更，即无法凭空创造币值或取得不属于攻击者的货币。节点不会接受无效的支付交易，所以诚实的节点永远不会接受包含无效交易的区块。攻击者只能试着改变其中一笔最近的交易来取回刚刚支付的货币。可以把诚实链和攻击者的链之间的竞争视为二项随机漫步（Binomial Random Walk），定义成功事件为诚实链延长了一个区块，使其领先性加 1；失败事件则是攻击者链被延长了一个区块，使得差距减 1。攻击者由落后迎头赶上诚实链的机率和赌徒破产问题（Gambler’s Ruin problem）类似，假设一个拥有无限筹码的赌徒一开始为赤字状态，但可能在经过无限次的尝试后达到收支平衡。我们可以计算出攻击者收支平衡或赶上诚实链的机率：

![](https://cdn-images-1.medium.com/max/800/1*yC5_kk2Ij60a8b-YNVJTwQ.png)

假设 p &gt; q，则攻击成功的机率将会随着攻击者需要赶上的区块数量增加而呈指数下降。因为攻击者的胜算不高，因此，若他没能幸运的快速成功，则他获得成功的机会就会随时间流逝而变得更加微乎其微。我们现在考虑的是，在一个新交易中充分确定发送者无法窜改交易之前，接收者必须等待多久。我们假设发送者是攻击者，它让接收者在一段期间内相信它已经支付款项，接着立刻将支付的款项重新支付给自己。当这个状况发生时，接收者会收到警报，但攻击者会希望这个警报为时已晚。接收者会产生一对新的金钥，并在签章之前会立即将公开金钥传给发送者，如此能避免以下情况发生：发送者预先准备一条区块链然后持续对此区块进行运算，一直到幸运地让这条区块链领先了诚实链，才立即执行支付。一旦交易被发送出去，不诚实的发送者就会开始秘密地准备包含该交易替代版本的平行链。接收者会等待直到交易被加到首个区块上且在那之后链结上 z 个区块，此时接收者仍无法得知攻击者实际的进展，但若假设每个诚实区块以平均的预定时间产生，则攻击者可能的进展会是一个 Poisson 分佈（Poisson Distribution），分布的期望值为：λ = z \* \(q/p\)。为了得到攻击者现阶段可以赶上的机率，我们将攻击者在该数量下依然能够赶上的机率乘上每个攻击者可以产生的进展量之 Poisson 机率密度：

![](https://cdn-images-1.medium.com/max/800/1*HkNSyCXjNp74guTnqxwPKA.png)

為了避免對無窮數列求和而將式子修改成：

![](https://cdn-images-1.medium.com/max/800/1*9YNgav_yQikcQ5QwBOZSRg.png)

以 C 語言去實現：

![](https://cdn-images-1.medium.com/max/800/1*9tC4g7TzBSSKOoaG_HjxQA.png)

可以從運算結果發現機率會隨著 z 值變大而呈指數下降：

![](https://cdn-images-1.medium.com/max/800/1*hoKp6q2wsJS6TWjuQzJfuQ.png)

以 P 值小於 0.1% 去求解 z 值：

![](https://cdn-images-1.medium.com/max/800/1*DODFPY3JICXmu-vKCx4GSw.png)

## 十二、結論

我们提出了一个**无须仰赖信任的电子交易系统**。我们首先讨论了**电子货币**的**数位签章**原理，它提供了拥有者很大的控制力，但仍不足以**防止双重支付（double-spending）**的发生。

为了解决这个问题，我们提出了一个採用**工作量证明**（proof-of-work）机制的端对端网路来**记录交易的公开历史资讯**，若诚实的节点掌控了 CPU 运算能力，则攻击者去窜改交易资讯是计算上不可行的。这个网路的强健之处在于其**结构**上的**简洁性**。节点们不太需要彼此协调就能同时执行工作。由于讯息不会被传送到任何特定的地方，因此节点们不需要被识别，只需要以最大努力原则被传送。

节点可以自由选择离开或重新加入网路，且会接受工作量证明链为当节点不在网路时所发生的交易事件之证明。节点以各自的 CPU 运算能力来进行投票，表决对有效区块的验证，以不断延长有效的区块链来表示接受，而以拒绝在无效的区块之后延长来表示拒绝。这个共识机制\(consensus mechanism\)包含了一个端对端的电子货币系统所需要的所有规则及奖励机制。

#### \[參考資料\] {#ecfa}

1. W. Dai, “b-money,” [http://www.weidai.com/bmoney.txt](http://www.weidai.com/bmoney.txt), 1998.
2. H. Massias, X.S. Avila, and J.-J. Quisquater, “Design of a secure timestamping service with minimal trust requirements,” In _20th Symposium on Information Theory in the Benelux_, May 1999.
3. S. Haber, W.S. Stornetta, “How to time-stamp a digital document,” In _Journal of Cryptology_, vol 3, no 2, pages 99–111, 1991.
4. D. Bayer, S. Haber, W.S. Stornetta, “Improving the efficiency and reliability of digital time-stamping,” In _Sequences II: Methods in Communication, Security and Computer Science_, pages 329–334, 1993.
5. S. Haber, W.S. Stornetta, “Secure names for bit-strings,” In _Proceedings of the 4th ACM Conference_ _on Computer and Communications Security_, pages 28–35, April 1997.
6. A. Back, “Hashcash — a denial of service counter-measure,” [http://www.hashcash.org/papers/hashcash.pdf](http://www.hashcash.org/papers/hashcash.pdf), 2002.
7. R.C. Merkle, “Protocols for public key cryptosystems,” In _Proc. 1980 Symposium on Security and_ _Privacy_, IEEE Computer Society, pages 122–133, April 1980.
8. W. Feller, “An introduction to probability theory and its applications,” 1957.

\[註1\] 作弊造假者、誠實節點、51%攻擊  
\[註2\]對於中本聰這篇論文中提到的攻擊者與誠實鏈之間的競爭分析，此篇[論文](https://arxiv.org/abs/1702.02867)提出了修正與更新。

